{
    "abstract": "Recently, several research works have been conducted on processingof preference queries over data streams. Preference queries are useful for manyapplication domains where users aim to find out the closest data items to theirwishes. This paper presents a new operator for the StreamPref language thatcan be employed to obtain the top-k data stream sequences according to temporal conditional preferences. Temporal conditional preferences can allow a userto express how past instants of a data stream may influence his preferences ata present instant. In order to evaluate this new operator, two new algorithmstrategies are also presented. The extensive set of experiments performed showthat the incremental strategy presents a superior performance in all experimental settings. Moreover, the results achieved show that the proposed operator hasa superior performance when compared to the equivalent operation in CQL.",
    "1. Introduction": " Preference queries aim to select the closest data items to the user wishes[Ribeiro et al. 2016]. Considering posing this type of query in data stream scenarios,preference queries must be processed efficiently to meet the high-speed data transfer requirement. There are several related research works concerned with skyline queries wherethe user preferences are represented as wishes for maximum or minimum attribute values [B6rzs6nyi et al. 2001, Lin et al. 2005, Tao and Papadias 2006]. However, there areapplication domains that require the users to express conditional preferences. This kindof preference allows the user to say how some attribute value influences their preferencesover another attribute. In order to illustrate, let us consider a soccer coach who wants to hire a player based on his nationality. He can express his desire considering a conditionalpreference as follows: “if the player is Brazilian then I prefer the attack position than themidfield position’. The data tuples in data stream scenarios have an implicit temporal information. Ifwe consider this rich information, it is possible to use conditional temporal preferencesto express how a user wishes at a given moment are impacted by past attribute values. Asan example, consider a coach who wants to monitor a data stream of a soccer match. The coach may use preferences such as “if the player was 1n offensive intermediary then I prefer that he stays in the same place instead of going to midfield’. We have been exploring this research topic in some preliminary works. We proposed a new formalism for reasoning with temporal conditional preferences [Ribeiro et al. 2017a] and used this formalismto define the first version of the StreamPref query language which allows querying datastreams with temporal conditional preferences [Ribeiro et al. 2017b]. The current version of the StreamPref query language is able to select dominantsequences. A sequence s is dominant if there is no other sequence better than s. However,if a query returns few dominant sequences, this result could not be enough for the user.The user may want to rank the sequences according to their preferences to get the bestk; sequences in this rank (i.e., the top-k sequences). For instance, the same soccer coachmentioned previously can be also interested in answering the following query: “Give methe best four sequences of positioning according to my preferences”. Others interestingpractical applications for queries with temporal preferences are stock market, telecommunications, web applications, sensor networks, among others. This paper presents a newoperator that incorporates the ability to select the top-k sequences according to temporalconditional preferences in the StreamPref query language. The main contributions of this paper can be summarized as follows: (1) We propose an extension of the StreamPref query language with a new operator that allows tofind top-k sequences according to temporal conditional preferences; (2) We present thedemonstration of the equivalence for the proposed operator and the existing operators;(3) We propose an efficient algorithm to evaluate the new operator; (4) We describe theresults of an extensive set of experiments comparing two strategies used by our algorithm. The remainder of this paper is organized as follows. Section 2 introduces the logical formalism and the existing operators of the StreamPref language. Section 3 presentsour new proposed operator to extend the StreamPref language. Section 4 describes thealgorithm used to evaluate the proposed operator. Section 5 presents the experiments anddiscusses the results. Section 6 discusses the main related research works. Finally, the",
    "2. The StreamPref Language": " This section presents the fundamental concepts regarding the preference model and theoperators of the StreamPref query language [Ribeiro et al. 2017a, Ribeiro et al. 2017b].Section 2.1 describes the preference model and Section 2.2 presents the existing operators.",
    "2.1. Temporal Conditional Preferences": " Let R(A1, ..., Ay) be a relational schema. A sequence s = (t1,...,¢,) over R is an orderedset of tuples, such that t; € Tup(R) for alli € {1,...,.2} where Tup(R) = Dom(A,) x... x Dom(A)) is the set of all tuples over R. The length of a sequence s is denoted by|s|. A tuple in the position 7 of a sequence s is denoted by s|i] while the notation s[7].Arepresents the attribute A in the position 7 of s. The set of all possible sequences over Ris denoted by Seq(R). The StreamPref formulas are based on propositions (A@a), wherea € Dom(A) and é € {<, <, =, 4, >, >} (see Definition 1). Let Q(A) be a proposition,Saga) = {a € Dom(A) | a - Q(A)} denotes the set of values satisfying Q( A). Definition 1 (StreamPref Formulas) The StreamPref formulas are defined as follows:(1) true and false are StreamPref formulas; (2) If F is a proposition then F is a Stream Pref formula; (3) If F and G are StreamPref formulas then (FAG), (F VG), (F since G),-F' and 7G are StreamPref formulas. A StreamPref formula F' is satisfied by a sequence s = (¢1,...,t,) at a positioni € {1,...,n}, denoted by (s,7) E F’, according to the following conditions: (1) (s,i)()(A) if and only if s|z7].A — Q(A); (2) (s,7) E FA G if and only if (s,7) E F and(s,7) E G; (3) (s,i) E FV Gif and only if (s,7) E F or (5,7) E G; (#& (s,i) E AFif and only if (s,7) A F; (5) (s,7) E (F since G) if and only if there exists 7 where1<j<iand(s,j) E Gand (s,k) E F forallk € {7 +1,...,7}. The true formulais always satisfied and the false formula is never satisfied. The StreamPref also has thefollowing derived formulas: Prev Q(A): Equivalent to (false since Q(A)), (s,7) -/ Prev Q(A) if and only ifi> land (s,i-—1) FE Q(A);SomePrev Q(A): Equivalent to (true since Q(A)), (s,i) FE SomePrev Q(A) ifand only if there exists 7 such that 1 < 7 <iand (s,7) FE Q(A); AllPrev Q(A): Equivalent to >(SomePrev-Q(A)), (s,i) - AllPrev Q(A) if andonly if (s, 7) E Q(A) for all 7 € {1,...,7 — 1}; Definition 2 formalizes the temporal conditions used by Definition 3 (tcp-rulesand tcp-theories). Example | shows a practical application using these definitions. Definition 2 (Temporal Conditions) A temporal condition is a formula F = F\\/.../\\F,,where F\\,..., F,, are propositions or derived formulas. The temporal components of F,,denoted by F~, are the conjunction of all derived formulas in F. The non-temporalcomponents of F’, denoted by F°®, is the conjunction of all propositions in F' and notpresent in F’~. The notation Att(F’) represents the attributes appearing in F. Definition 3 (TCP-Rules and TCP-Theories) Let R be a relational schema. A temporalconditional preference rule, or tcp-rule, is an expression in the format p : Cy > Qz >Q>|W,|, where: (1) The propositions Qs and (>, over the preference attribute Ag,represent the preferred values and non-preferred values, respectively, such that Sat MNSo: = {}; (2) W, C Ris the set of indifferent attributes such that A, ¢ W,; (3) Cois a temporal condition such that Att(C$) N {Ay} OW, = {}. A temporal conditionalpreference theory, or tcp-theory, is a finite set of tcp-rules. Example 1 Suppose a soccer coach who has access to an information system thatprovides real-time data concerning field positioning of the players. The data is in the stream positioning (pid, place, ball, direction) composed of theattributes pid (player identifier), place (field place), ball (ball possession) anddirection (moving direction). The field places are depicted in Figure 1. The attribute ball has the value 1 when the team has the ball possession and 0 for otherwise. For the attribute direction, the possible values are forward (fw), lateral(la) and rewind (rw). The coach has the following preferences: [P1] Lateral movesare better than forward moves, independent of ball possession; [P2] Forward movesare better than rewind moves, independent of ball possession; [P3] If, in a given moment, the team does not have the ball possession and, immediately before this moment, the player was at offensive intermediary and, always before this moment, the teamhad the ball, then I prefer midfield place than offensive intermediary place; [P4] If,in a given moment, the team has the ball possession and, immediately before this moment, the player was at midfield then I prefer offensive intermediary place than midfield place; These preferences can be expressed using the tcp-theory ® composed of thefollowing tcp-rules: :p, : > (direction = la) > (direction = fw)|bal1];yo : > (direction = fw) > (direction = rw)|ball]l; y3 : (ball =0) \\ Prev(place = oi) \\ AllPrev(ball = 1) > (place = mf) > (place = oi);ya: (ball =1)/A Prev(place = mf) > (place = oi) > (place =mf). A sequence s is preferred to a sequence s’ (or s dominates s’) according to a y,denoted by s >, s’, if and only if there exists a position 7 such that: (Z) All positionsbefore 7 must be identical in both sequences, s{j] = s’[j] for all 7 € {1,...,i-—1}; (2) Theposition 7 of s and s’ must satisfy the rule condition C,,, (s,7) -E C, and (s’,7) F Cy;(3) The position 7 of s has a preferred value and the position 7 of s’ has a non-preferredvalue, s[i].A, - Q? and s‘[i].A, - Q7; (4) Excluding the preference attribute A, andthe indifferent attributes of W,,, all attributes of position 7 must have identical values inboth sequences (ceteris paribus semantic), s|i].A’ = s'|i].A’ for all A’ ¢ ({A,}U W,).Example 2 presents a possible comparison of sequences. Example 2 Considering the sequences s = ((oi,1,la),(oi,1, fw), (01,0, fw)) ands’ = ((oi,1,la), (oi, 1, fw), (mf,0, fw)) and the tcp-theory ® of Example 1. It ispossible to say that s > ., s' since: (1) s[1] = s’[1] and s|2] = s'|2|; (2) (s,2) (ball = 0) A Prev(place = oi) A AllPrev(ball = 1) and (s',2) — (ball =0) A Prev(place = oi) A AllPrev(ball = 1); (3) s[3|].place = mf (preferredvalue), s'[3|.0lace = oi (non preferred value); (4) s|3|.ball = s'[3|].ball ands[3].direction = s'[3].direction (ceteris paribus semantic). The notation >» represents the transitive closure of U,-— ~y. Let ® be atcp-theory over a relational schema Seq(R). A sequence s € Seq() is preferredto s’ € Seq(R) according to ©, denoted by s >» s’, if there exists the sequencesS1,---; Sm41 © Seq(R) and the tep-rules y1,..., ~m € ® such that s1 >y, -. Sym Smtwhere s = s; and s’ = s,,,,. When two sequences cannot be compared, they are calledincomparable. For instance, consider the sequences s and s’ of Example 2 and the sequence s” = ((o2, 1, Ja), (ot, 1, fw), (mf, 1,la)). We have the comparisons s >, s’ ands' >, 8”. So, by transitivity, s >» s”. We must also consider consistency issues whendealing with order induced by rules to avoid inferences such as “‘a sequence is preferredto itself”. Please, see [Ribeiro et al. 2017a] for more details about consistency issues.",
    "2.2. StreamPref Operators": " The first step in the evaluation of a continuous tcp-query is the extraction of sequences using SEQ operator. This task is performed by the operation SEQ ,, 4(S), where X is theset of identifier attributes, n is the temporal range, d is the slide interval and S is the inputdata stream. The parameters n and d are used to delimit a portion of the data stream analogously to the selection performed by the sliding window operators [Arasu et al. 2016].The parameter X is a key used to group the tuples with the same identifier in a sequence.Example 3 demonstrates the use of the SEQ operator. positioning (pid, place, ball,direction) of Figure 2(a) and the preferences of Example 1. Now, suppose that acoach submits the following query to the information system: “[QI] At every instant, giveme the sequences of positioning that best fit my preferences over the last 3 seconds”. Theextraction of sequences is performed by the operation 5SEQ,,,; a}.3,1(positioning).Figure 2(b) shows, instant by instant, the result of this operation. As the user wants toconsider just the last three seconds, from instant 3, the old tuples are removed from the Let Z be a set of sequences and ©® be a tcp-theory.BESTSEQ,(Z) returns the dominant sequences in Z according to &. A sequences € Z is dominant according to ®, if As’ € Z such that s’ +» s. Example 4 showshow the BESTSEQ operator can be used to evaluate a query. Example 4 Let Z be the extracted sequences from Example 3 at instant 3. We can select the best sequences according to the tcp-theory in Example I by using the operation BESTSEQ,(SEQ,,.;..3;(positioning)). At instant 3, 81 > $2, $1 >@ $5,Sg >@ 55 and 83 >» 84. Thus, the result of query QJ at instant 3 is {81, 83}.",
    "3. The New Operator TOPKSEQ": " It is possible to use the BESTSEQ operator to obtain the top-k sequences. However,as we will see at the end of this section, the BESTSEQ operator is not suitable for thistask. Thus, in this paper, we propose the TOPKSEQ operator in order to select thetop-k sequences. The TOPKSEQ operator returns the top-k sequences of an input setof sequences Z according to a tcp-theory ®. The top-k sequences are the sequences of 7with the lowest preference level (Definition 4) Definition 4 (Preference level) Let ® be a tcp-theory. Let Z be a set of sequences. Thepreference level of a sequences s, denoted by level(s), is: (1) If fis' € Z such that s' > 8,then level(s) = 0; (2) Otherwise, level(s) = max{level(s’) | s’ € Zand s’ >» s} +1. Notice that the sequences with level zero are exactly those returned by theBESTSEQ operator. The TOPKSEQ operator is especially useful when the resultof the BESTSEQ operator has few sequences. In this case, the TOPKSEQ operatorcan complement the answer using sequences with greater levels (see Example 5). Example 5 Consider again the Example 4. The query result has just two sequences. Now,suppose that the coach has the following query: “[Q2] At every instant, give me the bestfour sequences of positioning according to my preferences over the last 3 seconds”. Thisquery is evaluated by the operation TOPKSEQg, ,(SEQ,,,;..3,:(positioning)). Atinstant 3, 81 > So, 8, > S5, 82 > S5 and 83 >» 84. So, the preference levelsare level(s,;) = 0, level(s3) = 0, level(sg) = max{level(s,)} + 1 = 1, level(s) =max{level(s3)} + 1 = 1 and level(ss) = max{level(s,), level(s2)} + 1 = 2. Thus theresult of query Q2 at instant 3 is { 1, 53, 82, 84}. The StreamPref language is an extension of the Continuous Query Language(CQL). The StreamPref operators do not increase the expression power of the CQL[Ribeiro et al. 2017b]. However, the equivalences are not trivial since the StremPref operators 1s equivalent to complex operations using several CQL operators and intermediaryrelations. So, these equivalences are not simple to be written by the user. Moreover, thenew operator has algorithms that are specially tailored to process queries more efficientlythan their CQL counterparts. The CQL equivalences for the SEQ and BESTSEQ operators were already demonstrated in our previous work [Ribeiro et al. 2017b]. Equations(1a)-(1d) show how we can use the BESTSEQ operator to evaluate the TOPKSEQoperator. As the BESTSEQ operator has a CQL equivalence, we can conclude that theTOPKSEQ operator has also a CQL counterpart. The term m of Equation (1d) represents the maximum preference level imposedby ®. This number is equal to the number of tcp-rules of ® in the worst case. Each set L;contains the sequences with preference level 7. The top-k sequences can be obtained by taking the sequences of these sets (following the preference level order) until k sequencesare reached. Despite the TOPKSEQ operator can be evaluated using the BESTSEQ operator, it is necessary to process all sequences at every instant to reach all preference levelsand sort the sequences by level. On the other hand, Section 4 presents algorithms whichstop the processing after the top-k sequences are obtained.",
    "4. The Algorithm": " As discussed in the previous section, the TOPKSEQ operator can be processed byusing the BESTSEQ operator a certain number of times. The algorithm GetTopkSeq(see Algorithm 1) employs this idea to evaluates the TOPKSEQ operator. First, thealgorithm creates a list to keep the sequences ordered by their preference level. The firstiteration of the loop uses the GetBestSeq routine to select the sequences with level zero.This routine basically removes the dominant sequences from 7%. Every iteration of theloop selects the sequences of the next level. This process stops when the list has at leastk; sequences or Z is empty. Algorithm 1: GetTopkSeq(®, k, Z) Algorithm 2: NaiveBestSeq(®, Z)1 L + NewList(); 1Z'<Z;2 while (|L| < k) and Z # {} do 2 foreach s,s’ € Z' do3 Z' — GetBestSeq(®, Z); 3 ifs >» s’ then Z’ «+ Z’ — {s'};4 L.append(Z’); 4 else if s’ +o sthen Z’ — Z’— {s}; 5 return L.getFirst(k); The GetBestSeq routine is basically an algorithm to evaluate the BESTSEQ operator. This algorithm can use a naive approach [Ribeiro et al. 2017a] or an incrementalapproach [Ribeiro et al. 2017b]. The naive approach must compare all sequences at every instant as addressed by the algorithm NaiveBestSeq (see Algorithm 2). On the otherhand, the incremental approach keeps an index structure updated using just the sequencechanges. This index structure is a sequence tree created using the sequences tuples. Figure 3 shows the sequence tree built with the sequences shown in Example 3 atinstant 3. Only the changed sequences are reallocated in the tree. The tree structure isuseful to find the position where two sequences must be compared (the fork nodes). Inaddition, a node keeps a preference hierarchy representing the children comparison. So,for each tree node, we can obtain the dominant nodes (and, by consequence, the dominantsequences) by using this preference hierarchy. Please see [Ribeiro et al. 2017b] for moredetails about the index structure. The algorithm /ncBestSeq (see Algorithm 3) obtains thedominant sequences by using the sequence tree. The algorithm starts at the tree root anduses recursive calls over the dominant children to reach all dominant sequences. Algorithm 3: IncBestSeq(nd)1Z¢nd.Z;  The naive algorithm must find the position to be compared. In the incrementalversion, the sequence tree already points to the position to be compared. In addition,the tree nodes use preference hierarchies to store many comparisons of previous instants.Only changed sequences cause updates in the tree and preference hierarchy. The complexity analysis of the algorithms takes into account the number of inputsequences (z), the length of the largest sequence (7m) and the number of tcp-rules in ® (m).We assume a constant factor for the number of attributes. The algorithm NaiveBestSeqmust compare every pair of sequences. The comparison start by looking for the firstdifferent position in the sequences. In the worst case, this position is the last one (7).Next, for the dominance test, the algorithm uses a deep first search strategy to find achain of sequences and rules. The search tree of this strategy has height and node degreeequal to m in the worst case. Thus, the complexity of the algorithm NaiveBestSeq isO(z? x (n+m™)) where the factor m™ is the cost of the dominance test. The incremental strategy to obtain the dominant sequences must update the sequence tree. In the worst case scenario, the degree of nodes is O(z) and the tree depth isO(n). We also have to consider the cost to deal with the preference hierarchy. Our preference hierarchy uses the partition strategy described in [Ribeiro et al. 2016]. The updatecost of this hierarchy is m*. Thus, the complexity of IncBestSeq is O(zn x m*) sinceevery sequence can cause the update of n nodes. The cost of the algorithm GetTopkSeg is related to the complexity and number ofcalls to the routine GetBestSeq. This routine is called O(m) times in the worst case. Thus,the complexity of the algorithm GetTopkSeg is the cost of this routine multiplied by m. Indata stream scenarios, the incremental algorithms usually are faster than naive algorithms.The experimental results of the next section show this tendency in the algorithms whenprocessing the TOPKSEQ operator.",
    "5. Experimental Results": " We conducted an extensive set of experiments to analyze the performance (runtime) andthe memory usage of the algorithms used to evaluate the TOPKSEQ operator. Allexperiments were carried out on a machine with a 3.2 GHz twelve-core processor and 32GB of main memory, running Linux. The algorithms were implemented in a Data StreamManagement System (DSMS) prototype using Python language’. The same tool used in [Ribeiro et al. 2017b] was employed to generate the synthetic datasets for our experiments”. This tool generates streams composed of integerattributes. In addition, it allows evaluating several parameter settings. For each experi ment, we varied one parameter and fixed a default value for the others. We do not includethe CQL equivalence in our experiments because this equivalence was already discussedin [Ribeiro et al. 2017b]. The experimental results described in [Ribeiro et al. 2017b]showed higher runtime and greater memory usage for the CQL equivalence due to itsvarious intermediary operation and temporary relations. Table 1. The parameters of the experiments: (a) Data generation; (b) Sequenceextraction; (c) Preferences. (a) (b) (c)Param. Variation Param. Variation Param. VariationATT 8, 10,12,14,16 RAN 20, 40, 60, 80, 100 RUL 8, 16, 24, 32, 40NSQ 8, 16,24,32,40 SLI 10, 20, 30, 40, 50 LEV 1, 2,3, 4,5 Table | shows the variation of the parameters (with default values in bold). Thenumber of attributes (ATT) allows for the evaluation of the algorithm behavior according to different data dimensionality. The number of sequences (NSQ) controls how thenumber of tuples per instant (equal to NSQ x 0.75) affects the algorithms. The temporalrange (RAN) delimits the maximum length of the sequences and the slide interval (SLDis related to the number of deletions when the sliding window moves. The number of rules (RUL) and the maximum preference level (LEV) are employed in the generation of the preferences. These parameters allow us to evaluate howdifferent preferences affect the algorithms. We used rules in the form y; : First /AQ(A3) 4 Q* (As) > Q7(As)[Aa, As] and giy1 + PrevQ(A3) \\ SomePrevQ(A,) AAllPrevQ(As) A Q(A3) > Qt(Azg) > Q7(Az2)[Ag, As] having variations on propositions Q* (Az), Q7(A2), Q(A3), Q(Az), Q(As). The number of iterations is RAN plusthe maximum slide interval and the sequence identifier is the attribute A,. Moreover, weexecuted experiments varying the number of top-k sequences (TOP). For this parameter,we used the values 4, 8, 12, 16 and 20 (8 is the default value). Greater values for TOPparameter causes more iterations in the loop of the GetTopkSeq algorithm. 253 30 ee 60 30 20 ee215 40 20 15= 10 | 20 __f 10 doer Or . 10ee 5o---O---e-- 7 OTP een o-- 8 8 ) oer? 57778 77 78> --98---4~ 8 10 12 14 16 8 16 24 32 40 20 40 60 80 100 10 20 30 40 505 26 9---0--- 7 > 3 _® 30 4 26P ~~~ LgSh 25 -~ 8 28 87 77> O©---5 23 | --®7 24 | 87g 2 od 22 ee 228 10 12 14 16 8 16 24 32 40 20 40 60 80 100 10 20 30 40 50Attributes number (ATT) Sequences number (NSQ) Temporal range (RAN) Slide interval (SLD Figure 4 shows the results obtained for the experiments with the parameters ATT,NSQ, RAN and SLI. Analyzing these results we observe that the incremental algorithmpresented a better performance and a greater memory usage. This behavior is due to themaintenance of the index structure which speeds up the processing but consumes morememory. Considering the results of the experiments with the parameters NSQ and RAN, it is possible to see that for a greater number of sequences, the algorithm has to performmore comparisons consuming more process time. Moreover, the memory usage of the incremental algorithm increases to keep an index for more sequences. It is also important tonotice that the executions with bigger temporal range imply in longer sequences resulting Figure 5 presents the results of the experiments with the parameters RUL, LEVand TOP. The results obtained are similar to the ones obtained for the other parameters.Analyzing these results it is possible to see that the incremental algorithm showed a betterperformance and a higher memory usage. Among these results, it is important to highlightthe results obtained with the variation in the number of rules (RUL). The naive algorithm presented a poor efficiency when dealing with more rules as more comparisons are required. The incremental algorithm, however, is few affected due to its index structure asaddressed in Section 4.",
    "6. Related Work": " The pioneering work on preference queries was the proposal of the skyline queries[Borzsényi et al. 2001]. This research work provided support for many related studies.In [Chan et al. 2006], the authors introduced the concept of k-dominance. A tuple ¢ kdominates a tuple ¢’ if t is better than ¢’ in at least k attributes. The research work describedin [Yiu and Mamoulis 2007] specified how to rank tuples using a dominance degree. Thedominance degree of tuple ¢ is the number of tuples dominated by t. The CPrefSQL querylanguage proposed a new preference operator to compare tuples according to conditionalpreferences [de Amo and Ribeiro 2009]. The first research works about continuous preference queries were proposed by[Lin et al. 2005] and [Tao and Papadias 2006]. In [Lin et al. 2005] the authors exploredthe n-of-N problem for skyline queries, where a query is evaluated over the n most recenttuples, with n < N. The work of [Tao and Papadias 2006] designed algorithms to incrementally compute the preferred tuples over a sliding window with the most recent tuples.The work of [Kontaki et al. 2012] proposed algorithms for the evaluation of continuouspreference queries over the most recent data, where each tuple has a timestamp and a validity interval. The evaluation of continuous preference queries using a graph-based indexwas introduced by [Santoso and Chiu 2014]. This work also designed an algorithm thatoutperforms the algorithms proposed in [Kontaki et al. 2012]. The first research work concerning the evaluation of continuous queries with conditional preferences (continuous cp-queries) were proposed by [de Amo and Bueno 2011,Petit et al. 2012]. In [de Amo and Bueno 2011], the authors presented an incremental algorithm based on ancestor lists for evaluating continuous cp-queries. The study describedin [Petit et al. 2012] uses a graph structure to perform the same task. In the work of [de Amo and Giacometti 2007], the authors proposed the TPrefformalism to express temporal conditional preferences. The StreamPref formalism, proposed in [Ribeiro et al. 2017a], is a refinement of the TPref formalism. The StreamPref ismore suitable for reasoning over data streams. In [Ribeiro et al. 2017b], the StreamPrefformalism was used to define the query language StreamPref. The StreamPref languagewas originally composed of the operators SEQ and BESTSEQ. The queries using theBESTSEQ operator are similar to skyline queries since both return the dominant elements according to the preferences. On the other hand, the queries with TOPKSEQoperator are a kind of top-k dominant query. In this case, the sequences are ranked using the preference level. We also should mention the importance of the CQL language[Arasu et al. 2006]. The CQL was not designed to work with preference queries, but it isa solid and expressive SQL-based declarative language for general purpose queries overdata streams. In addition, the StreamPref query language is an extension of the CQL.",
    "7. Conclusion": " This paper presented the new operator TOPKSEQ for the StreamPref query language.The TOPKSEQ uses the preference level imposed by temporal conditional preferences to find the top-k sequences. First, we revisited the existing operators SEQ andBESTSEQ of the StreamPref. The SEQ operator extracts sequences from a data streamand the BESTSE(Q is used to select the dominant sequences according to temporal conditional preferences. Considering that the BESTSEQ operator is not enough to obtain agood result to the user in all situations, the TOPKSEQ can be used to complement theresults obtained using sequences with higher preference level. We demonstrated the equivalence between the operators TOPKSEQ andBESTSEQ. Moreover, we proposed an algorithm to evaluate the TOPKSEQ operator. This algorithm can use both the naive and the incremental strategies already proposed for the BESTSEQ operator. The extensive set of experiments performed showeda slightly greater memory usage for the incremental strategy recompensed by its superiorperformance. Our future research directions include the possibility to use new approaches torank the sequences beyond the preference level. We are also interested in exploring anew preference formalism to compare sequences considering not only the first differentposition but using a kind of distance based on preferences. Another future work is thedevelopment of algorithms for preference mining. The discovered preferences can beused in queries to monitor data streams. Acknowledgments. The authors would like to thank the Research Agencies CNPq,CAPES and FAPEMIG for supporting this work. Arasu, A., Babcock, B., Babu, S., Cieslewicz, J., Datar, M., Ito, K., Motwani, R., Sri vastava, U., and Widom, J. (2016). STREAM: The Stanford Data Stream ManagementSystem, pages 317-336. Springer, Berlin, Heidelberg. Arasu, A., Babu, S., and Widom, J. (2006). The CQL continuous query language: semantic foundations and query execution. The VLDB Journal, 15(2):121-142. Borzs6nyi, S., Kossmann, D., and Stocker, K. (2001). The skyline operator. In JCDE,pages 421-430, Heidelberg, Germany. Chan, C.-Y., Jagadish, H. V., Tan, K.-L., Tung, A. K. H., and Zhang, Z. (2006). Finding k-dominant skylines in high dimensional space. In ACM SIGMOD InternationalConference on Management of Data, pages 503-514, Chicago, USA. de Amo, S. and Bueno, M. L. P. (2011). Continuous processing of conditional preferencequeries. In SBBD, Floriandépolis, Brasil. de Amo, S. and Giacometti, A. (2007). Temporal conditional preferences over sequencesof objects. In ICTAI, pages 246-253, Patras, Greece. de Amo, S. and Ribeiro, M. R. (2009). CPref-SQL: A query language supporting conditional preferences. In ACM SAC, pages 1573-1577, Honolulu, Hawa, USA. Kontaki, M., Papadopoulos, A. N., and Manolopoulos, Y. (2012). Continuous top-k dominating queries. [EEE Trans. on Knowledge and Data Eng. (TKDE), 24(5):840-853. Lin, X., Yuan, Y., Wang, W., and Lu, H. (2005). Stabbing the sky: Efficient skylinecomputation over sliding windows. In JCDE, pages 502-513, Tokyo, Japan. Petit, L., de Amo, S., Roncancio, C., and Labbé, C. (2012). Top-k context-aware querieson streams. In DEXA, pages 397-411, Vienna, Austria. Ribeiro, M. R., Barioni, M. C. N., de Amo, S., Roncancio, C., and Labbé, C. (2017a).Reasoning with temporal preferences over data streams. In FLAIRS, Marco Island, Ribeiro, M. R., Barioni, M. C. N., de Amo, S., Roncancio, C., and Labbé, C. (2017b).Temporal conditional preference queries on streams. In /nternational Conference onDatabase and Expert Systems Applications (DEXA), Lyon, France. Ribeiro, M. R., Pereira, F S. F, and Dias, V. V. S. (2016). Efficient algorithms forprocessing preference queries. In ACM SAC, pages 972-979, Pisa, Italy. Santoso, B. J. and Chiu, G.-M. (2014). Close dominance graph: An efficient frameworkfor answering continuous top-dominating queries. [EEE Transactions on Knowledgeand Data Engineering (TKDE), 26(8):1853-1865. Tao, Y. and Papadias, D. (2006). Maintaining sliding window skylines on data streams.IEEE TKDE, 18(3):377-391. Yiu, M. L. and Mamoulis, N. (2007). Efficient processing of top-k dominating querieson multi-dimensional data. In International Conference on Very Large Data Bases"
}