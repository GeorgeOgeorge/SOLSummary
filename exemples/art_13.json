{
    "abstract": "A geometrical pattern is a set of points with all pairwise distances (or,more generally, relative distances) specified. Finding matches to such patternshas applications to spatial data in seismic, astronomical, and transportationcontexts. Finding geometric patterns is a challenging problem as the potentialnumber of sets of elements that compose shapes is exponentially large in thesize of the dataset and the pattern. In this paper, we propose algorithms to findpatterns in large data applications. Our methods combine quadtrees, matrixmultiplication, and bucket join processing to discover sets of points that matcha geometric pattern within some additive factor on the pairwise distances. Ourdistributed experiments show that the choice of composition algorithm (matrixmultiplication or nested loops) depends on the freedom introduced in the querygeometry through the distance additive factor. Three clearly identified blocks ofthreshold values guide the choice of the best composition algorithm.",
    "1. Introduction": " The availability of large datasets in science, web and mobile applications enables newinterpretations of natural phenomena and human behavior. Consider the following use case: Scenario 1. An astronomy catalog is a table holding billions of sky objects from aregion of the sky, captured by telescopes. An astronomer may be interested in identifyingthe effects of gravitational lensing in quasars, as predicted by Einstein’s General Theoryof Relativity [Einstein 2015]. According to this theory, massive objects like galaxies bendlight rays that travel near them just as a glass lens does. Due to this phenomenon, an earthtelescope would receive two or more virtual images of the lensed quasar leading to acomposed new object (Figure 1), such as the Einstein cross [Overbye 2015]. In the scenario above, constellations, such as the Einstein cross, are obtained fromcompositions of individual elements in large datasets in some spatial arrangement withrespect to one another. Thus, extracting constellations from large datasets entails matching geometric pattern queries against sets of individual data observations, such that eachset obeys the geometric constraints expressed by the pattern query. Solving a constellation query in a big dataset is hard due to the sheer numberof possible compositions from billions of observations. In general, for a big dataset Dand a number & of elements in the pattern, an upper bound for candidate combinations(\\? is the number of ways to choose k items from D. This paper focuses primarily onpure constellation queries (when all pairwise distances are specified up to an additivefactor). We develop parallel algorithms that reduce the number of possible candidate setsby applying local and global constraints. The remainder of this paper is organized as follows. Section 2 formalizes theconstellation query problem. Section 3 presents our techniques to process constellationqueries. In section 4, we preset our algorithms. Section 5 discusses our experimentalenvironment and discusses the evaluation results, followed by section 6 that discusses",
    "2. Problem Formulation": " In this section, we introduce the problem of answering pure Constellation Queries ona dataset of objects. A Dataset D defined as a set of elements (or objects) D ={e1,€2,...,€n}, in which each e;, 1 < i < n, is an element of a domain Dom. Furthermore, e; =< atr,,atr2,...,atr, >, such that atr; (1 < 7 < m)is a value describinga characteristic of e;. A constellation query Q. = {41, g2,---;%} is (i) a sequence of k elements of domain Dom, (11) the distances between the centroids of each pair of query elements that define the query shape and size with an additive allowable factor €, and (111) an element-wisefunction f(e, q) that computes the similarity (e.g. in brightness at a certain wavelength)between elements e and g up to a threshold 6. A sequence s of elements of length & in D property matches query @ if everyelement s[7] in s satisfies fe(s|i], q;) up to a threshold @ and for every 7, 7 < k: (i) the distance between elements s[i] and s[7] is within an additive factor € of the distance betweenq and q;, which is referred to as distance match. The solutions obtained using propertymatch and distance match to solve a query Q are referred to as pure constellations.",
    "3. Pure Constellation Queries": " Applying pure constellation to find patterns such as the Einstein cross over an astronomycatalog requires efficient query processing techniques as the catalog may hold billions ofsky objects. In this context, efficiently answering pure constellation queries involves constraining the huge space of candidate sets (i.e. subsets of the catalog with the same number ofstars as the query).",
    "3.1. Reducing Data Complexity using a Quadtree": " A constellation query looks for patterns in large datasets, such as the 2MASS catalog.Computing constellation queries involves matching each star to all neighboring stars withrespect to the distances in the query, a costly procedure in large catalogs. To reduce thiscost, we adopt a filtering process that eliminates space regions where solutions cannotexist. The filtering process is implemented on top of a quadtree [Samet 1990], constructed over the entire input dataset. The quadtree splits the 2-dimensional catalog spaceinto successively refined quadrangular regions. A node in the tree is associated to a spatial quadrant. The geometric center of thequadrant is the node centroid and is used as a representative for all stars located in thatquadrant, for initial distance matching evaluation. The quadtree data structure includes: aroot node, at level L = 0; a list of intermediary nodes, with level 1 < L < tree_height — 1; and leaf nodes. To avoid excessive memory usage, data about individual stars are stored The algorithm begins by determining the level of the quadtree L, at which the ¢€error bound exceeds the diameter of the node. If we make the reasonable assumption that« is less than the minimum distance between elements in the query (minq), then at heightL,. no two stars would be covered by a single quadtree node. Given a star s that will correspond to the centroid go of the pattern being matched,the first step is to eliminate all parts of the quadtree that could not be relevant. Thealgorithm finds the node at level L, containing s. That is called the query anchor node.The algorithm finds the nodes that lie within a radius p of the query anchor node, wherep 1s the maximum distance plus the additive error bound ¢€ between the centroid of thequery pattern and any other query element. As depicted in Figure 3, in (a) a query Q hasan anchor element qo and the largest distance to the remaining query elements dp». In(b), a star is picked as an anchor and all neighboring stars within distance dp» + € arepreliminary candidates for distance matching. Figure 3. (a) Pure constellation query with anchor and maximum distance (b)Neighboring elements of anchor element Next the algorithm determines for each pattern element g;, which stars are at distance dist(qo, g;) from s within an additive factor of €. Such stars might correspond to q; inthe case where s corresponds to go. For each pair of nodes nl and n2, where nl containss and n2 may contain stars that correspond to q; for some 7, the algorithm checks whetherthe distance between the centroids of nl and n2 matches dist(qo, g;), taking into accountboth the diameter of the nodes and the error bound. This procedure filters out all node If n2 has not been filtered out, then a simple test determines whether going onelevel down the tree is cost effective as opposed to testing pairs of individual stars in thetwo nodes. That test consists of determining whether any pair of children of nl and n2will be eliminated from consideration based on a distance test to the centroids of thosechildren. If so, then the algorithm goes down one level. The same matching procedure isapplied to the children nodes of nl and n2 respectively. If not, then the stars for nl and n2are fetched and any star in n2 that lies within an € additive bound of s is put into bucket",
    "3.2. Composition algorithms": " In this section, we discuss approaches to join the buckets produced by the filtering step.As we will observe in section 5, composition algorithms are the most time consumingoperation in processing constellation queries. A given anchor node may generate buckets containing thousands of elements. Thus, finding efficient composition algorithms iscritical to efficient overall processing.",
    "3.2.1. Buckets Nested Loop (Bucket-NL)": " An intuitive way to produce constellations for a given anchor element is by directly joining the buckets of candidate elements considering the corresponding pairwise distancesbetween query elements as the join predicate. In this approach, each bucket is viewedas a relation, having as a schema their spatial coordinates and an id, B;(starid, ra, dec).A solution is obtained whenever a tuple is produced having one neighbor element fromeach bucket, such that the distances between each element in the solution distance-match those among respective query elements, +/- «. Bucket-NL assumes a nested loop algorithm to traverse the buckets of candidate elements and checks for the distance predicates.Thus, applying a distance-match constraint corresponds to applying a cyclic join amongall buckets in the bucket set followed by a filter among non-neighbors in the cycle. Forexample, Bucket-NL would find pairs (tl, t2) where tl is from 6; with and t2 from 5;if dist(tl, t2) is within dist(p;, p;41) +/- e«. Then given these pairs for buckets 1 and 2,buckets 2 and 3, buckets 3 and 4, etc, Bucket-NL will join these cyclically and then forany k-tuple of stars sl, s2, ..., sk that survive the join, Bucket-NL will also check thedistances of non-neighboring stars (e.g. check that dist(s2,s5) = dist(p2, ps) +/- €).",
    "3.2.2. Matrix Multiplication based approaches": " The Matrix Multiplication (/ M) based approaches precede the basic Bucket_N L algorithm by filtering out candidate elements. Here are the details: recall that bucket 5; holdselements for the candidate anchor that correspond to dist(go, g;) +/- €. Compute the matrices: M1(B,, By), M2( Bo, B3), M3(B3, B,) where Mi(B;, B;,,) has a | in location j,k if the jth star in 6; and the kth star in 6:1, is within dist(p;, p;11) +/- e. The product ofmatrices indicates the possible existence of solutions for a given anchor element, as longas the resulting matrix contains at least a one in its diagonal. The MM approach can beimplemented with fast matrix multiplication algorithms [R. Bank 1993][U. Zwick 2005]and enables quick elimination of unproductive bucket elements.",
    "3.2.3. MMM Filtering": " Matrix multiplication may be applied multiple times to eliminate stars that cannot be partof any join. The idea is to apply & matrix multiplications, each with a sequence of matricesstarting with a different matrix (i.e. a 5; bucket appears in the first and last matrices of asequence, for 1 <2 < k). The resulting matrix diagonal cells having zeros indicate thatthe corresponding element is not part of any solution and can be eliminated. For example,for buckets B,, Bj, B3; and matrices M1(B,, By), M2( Bo, Bs), M3(B3, By), we would mn < M1-M2.M3 >; < M2-M3.-M1 >and < M3-M1-M2 >. For themultiplication starting with say (71, elements in bucket 6, with zeros in the resultingmatrix diagonal are deleted from 5), reducing the size of the full join.",
    "3.2.4. Matrix Multiplication Compositions": " The matrix multiplication filtering is coupled with a composition algorithm leading toMM_Composition algorithms. The choices explore the tradeoff between filtering moreby applying the MMM filtering strategy or not. The MMM_NL strategy uses the MMM filtering strategy to identify the elementsof each bucket that do not contribute to any solutions and can be eliminated from theirrespective buckets. Next, the strategy applies Bucket_NL to join the buckets with elementsthat do contribute to solutions. The MM_NL considers a single bucket ordering with the anchor node bucket at thehead of the list. Thus, once the multiplication has been applied, elements in the anchornode bucket that appear with zero in the resulting matrix diagonal are filtered out fromits bucket. Next, the strategy applies Bucket_NL to join the buckets with anchor elementsthat do contribute to solutions.",
    "4. Algorithms for Pure Constellation Queries": " To compute Pure Constellation Queries, the overall algorithm implements propertymatching and finds matching pairs, whereas the composition algorithms implement distance matching as discussed above.",
    "4.1. Main Algorithm": " The Constellation Algorithm depicts the essential steps needed to process a Constellationquery. The main function is called ExecuteQuery. It receives as input a query gq, datasetD, element predicate fe, similarity threshold @, and error bound e. At step 1, a quadtreeentry level L, is computed. Next, a quadtree gt is built covering all elements in D andhaving height L,. Figure 2.a illustrates a typical quadtree built on top of heterogeneouslydistributed spatial data. The quadtree nodes at level L,, become the representatives of starsfor initial distance matching. Considering the list of nodes at level L,, an iteration pickseach node, takes it as an anchor node, and searches gt to find neighbors. The geometriccentroid of the node quadrant is used as a reference to the node position and neighborhoodcomputation. Next, each pair (anchor node, neighbor) is evaluated for distance matchingagainst one of the query pairs: (query anchor, query element) and additive factor e. Matching nodes contribute with stars for distance matching or can be further split to eliminatenon-matching children nodes. Matching stars are placed in a bucket holding matches forthe corresponding query element. The Compose Function, applies a composition algorithm, described in the previous section, between buckets B = {B,, Bo,..., By}, for g.size = k + 1, to see whichk+1-tuples match the pure constellation query. The composition algorithm builds a queryexecution plan to join buckets in B. The distance matching of elements in buckets 5; andB;,i # j, and i,7 # anchor, is applied by checking their pairwise distances +/- €, withrespect to the corresponding distances between q; and q;, in q. The choice between running Bucket_NL or a MM _filtering algorithm to implementelement composition, as our experiments in section 5 will show, is related to the sizeof the partial join buckets. For dense datasets and queries with an error bound close tothe average distance among stars, lots of candidate pairs are produced and MM _filteringimproves composition performance, see Figure 4.b.",
    "5. Experimental Evaluation": " In this section, we start by presenting our experimental setup. Next, we assess the differentcomponents of our implementation for Constellation Queries.",
    "5.1. Set Up": "",
    "5.1.1. Dataset Configuration": " The experiments focus on the Einstein cross constellation query and are based onan astronomy catalog dataset obtained from the Sloan Digital Sky Survey (SDSS), aseismic dataset, as well as synthetic datasets. The SDSS catalog, published as partof the data release DR12, was downloaded from the project website link (hitp : skyserver.sdss.org/CasJobs/).We consider a projection of the dataset including attributes (obj 1D, ra, dec, u, 9,1, 1, Z).The extracted dataset has a size of 800 MB containing around 6.7 million sky objects. From the downloaded dataset, some subsets were extracted to produce datasetsof different size. Additionally, in order to simulate very dense regions of the sky, webuilt synthetic datasets with: 1000, 5000, 10000, 15000, and 20000 stars. The syntheticdataset includes millions of scaled solutions in a very dense region. Each solution is amultiplicative factor from a base query solution chosen uniformly within an interval ofscale factors s = [1.00000001, 1.0000009].",
    "5.1.2. Calibration": " We calibrated constellation query techniques using the SDSS dataset described above anda 3D seismic dataset from a region on the North Sea: Netherlands Offshore F3 BlockComplete !. The procedure aimed at finding the Einstein Cross in the astronomy catalogand a seismic dome within the North Sea dataset, using our constellation query answeringtechniques. In both cases, the techniques succeeded in spotting the right structures amongbillions of candidates.",
    "5.1.3. Computing Environment": " The Constellation Query processing is implemented as an Apache Spark dataflow runningon a shared nothing cluster. The Petrus.Incc.br cluster is composed of 6 DELL PE R530 servers running CENTOS v. 7.2, kernel version 3.10.0327.13.1.el7.x86_64. Each cluster node includes a 2 Intel Xeon E5-2630 V3 2.4GHz processors,with 8 cores each, 96 GB of RAM memory, 20MB cache and 2 TB of hard disk. We arerunning Hadoop/HDFS v2.7.3, Spark v2.0.0 and Python v2.6. Spark was configured with50 executors each running with 5GB of RAM memory and | core. The driver module wasconfigured with 80GB of RAM memory. The implementation builds the quadtree at themaster node, at the driver module, and distributes the list of nodes at the tree entry level.Each worker node then runs the property_matching and distance_matching algorithms.Finally, answers are collected in a single solution file.",
    "5.2. The Effectiveness of the Descent Tree algorithm": " The quadtree structure enables reducing the cost of constellation query processing by restricting composition computation to stars in pairs of nodes whose spatial quadrants matchin distance. Selected matching pair nodes are evaluated for further splitting, according tocost model. In this section, we investigate the efficiency of the algorithm. We compare thecost of evaluating the stars matching at the tree entry level with one that descends basedon the cost model. We ran the buildQuadtree function with dense datasets and measured the difference in elapsed-time in both scenarios. In terms of number of comparisons for | millionstars, the cost model saves approximately 1.9x, leading to an order of magnitude on execution time savings.",
    "5.3. Composition Algorithm Selection": " In this section, we discuss the characteristics of the proposed composition algorithms. In the first experiment a constellation query based on the Einstein cross elements isrun for each composition algorithm and their elapsed-times are compared. The elapsedtime values correspond to the average of 10 runs measuring the maximum among allparallel execution nodes in each run. The geometric nature of constellation queries and the density of astronomical catalogs make the distance additive factor € a very important element in query definition. Asour experiments have shown, variations in this parameter may change a null result set toone with million of solutions. The experiments evaluate two classes of composition algorithms. In one class, we use the Bucket_NL algorithm and, in the second one, we includethe adoption of various Matrix Multiplication filtering strategies. The experiment results are depicted in Figures 4.a and 4.b. In these plots, thehorizontal axis presents different error tolerance values €, while the vertical axis shows theelapsed-time of solving the constellation query using one of the composition algorithms. Figure 4.a shows basically two scenarios. For very small ¢, < 10~®, the number ofcandidate elements in buckets is close to zero, leading to a total of 32 anchor elements tobe selected and producing 52 candidate shapes. In this scenario, the choice of a composition algorithms is irrelevant, with a difference in elapsed-time of less than 10% amongthem. It is important to observe, however, that such a very restrictive constraint may eliminate interesting sets of stars. Unless the user 1s quite certain about the actual shape of itsconstellation, it is better to loosen the constraint. The last blocks of runs involving the composition algorithms in Figure 4.a showsthat the results are different when increasing ¢€ by up to a factor of 100. Considering¢ = 2,0 x 10~-°,we obtain 522,578 productive anchor elements and an average of closeto one element per bucket. The total number of candidate shapes rises to 12.6 million.In this setting, Bucket_NL is very fast, as it loops over very few elements in the buckets to discover solutions. The overhead of computing matrix multiplication is high, soBucket_NL is a clear winner. This scenario continues to hold up to e€ = 2 x 107+, seeFigure 4.a. In this range, Bucket_N L is faster than MM_NL and MMM_NL by 214%and 240%, respectively. Figure 4.b highlights the behavior of algorithms under additive error tolerance values. The flexibility introduced by « = 6 x 107? generates 6.7 million productive anchorelements and a total of 7.1 billion solutions, with average elements per bucket of 10. Inthis scenario, eliminating non-productive anchor elements, close to 300, 000, by filteringusing matrix multiplication eliminates the need of computing nested loops over approximately 405 candidate elements in buckets. Thus, running fast matrix multiplication as a Figure 5 shows the point at which matrix multiplication becomes beneficial: when€ = 6.0 x 107° matrix multiplication starts to efficiently filter out anchor nodes and sothe reduction in nested-loop time compensates for the cost of performing matrix multiplication. The gains observed by running matrix multiplication algorithms as a pre-filteringstep before nested loop for ¢ in range 6 x 107° and 9 x 107? are up to 45.6% for MM_NLand 34.6% for MMM_NL. Figures 5.a and 5.b zoom in on the Matrix Multiplication algorithms. The formershows the results with thresholds not less than 1 x 107°. In this range, we can observe aninversion in performance between MM_NLI and MM M_NL. The inflexion point occursafter ¢ > 2 x 107°. Threshold values below the inflexion point include anchor nodes withvery few elements in buckets. In this scenario, computing multiple matrix multiplicationis very fast. Moreover, elements that appear with zeros in the resulting matrix diagonalcan be looked up in buckets and deleted, before the final nested-loop. The result is again of up to 14% in elapsed-time with respect to MM_NL. From the inflexion pointon, Matrix_Multiplication_N L is the best choice with gains up to 30% with respectto MMM_NL. The selection among composition algorithms is summarized in Table 1, Finally, the matrix multiplication MM algorithm is, as expected, a good choice forexistential constellation queries which ask whether any subset of the dataset matches the query but does not ask to specify that subset. In this scenario, once the matrix multiplication indicates a resulting matrix diagonal with all zeros, the anchor element produces nocandidate shape and can be eliminated from the existential query result. Figure 5. Zoom In on Matrix Multiplication: large threshold (a) Zoom In on MatrixMultiplication: low threshold (b)",
    "5.4. Pure Constellation Scale-up": " We investigated Pure CQ scale-up adopting the set of dense datasets (see section 5.1.1),error bound epsilon = 4.4710~° and Bucket_NL for the composition algorithm. The execution produced solutions of size: zero, 21, 221, 1015, and 2685. The run with 1000 starsdataset produced zero solutions, which shows the relevance of tunning the error boundfor a given dataset and the restrictions imposed by Pure CQ. Apart from the runs withthe 15,000 stars dataset, the variations in time followed the increase in the number of solutions.This indicates that non solutions are quickly discarded and the time is mostlydue to producing solutions. Figure 6 depicts the results, where time corresponds to theelapsed-time in seconds of the parallel execution.",
    "6. Related Work": " Finding collections of objects having some metric relationship of interest is an area withmany applications. The problem has different names depending on the discipline, including Object Identification [Singla and Domingos 2005], Graph Queries [Zou et al. 2011],Pattern Matching and Pattern Recognition [Bishop 2006]. Pattern recognition research focuses on identifying patterns and regularities in data[Bishop 2006]. Graphs are commonly used in pattern recognition due to their flexibilityin representing structural geometric and relational descriptions for concepts, such as pixels, predicates, and objects [Jolion 2001]. In this way, problems are commonly posed asa graph query problem, such as subgraph search, shortest-path query, reachability verification, and pattern match. Among these, subgraph matching queries are related to our In a subgraph query, a query is a connected set of nodes and edges (which mayor may not be labeled). A match is a (usually non-induced) subgraph of a large graphthat is isomorphic to the query. While the literature in that field is vast [[Zou et al. 2009],[Giugno and Shasha 2002]], the problem is fundamentally different, because there is nonotion of space (so data structures like quadtrees are useless) and there is no distancenotion of scale (the € that plays such a big role for us). Finally, constellation queries are a class of package queries (PQ), Brucato et al.[Brucato et al. 2016].",
    "7. Conclusion": " In this paper, we introduce constellation queries, specified as a geometrical compositionof individual elements from a big dataset. We illustrate the application of ConstellationQueries in astronomy (e.g. Einstein crosses). We have designed procedures to efficiently compute both pure ConstellationQueries. First, we reduce the space of possible candidate sets by associating to eachelement in the dataset neighbors at a maximum distance, corresponding to the largest distance between any two elements in the query. Next, we filtered candidates yet furtherinto buckets through the use of a quadtree. Next, we used a bucket joining algorithm,optionally preceded by a matrix multiplication filter to find solutions. Our experiments execute on Spark, running on the neighboring dataset distributedover HDFS. Our work shows that our filtering techniques having to do with quadtrees areenormously beneficial, whereas matrix multiplication is beneficial only in high density There are numerous opportunities for future work, especially in optimization for",
    "8. Acknowledgment": " This research is partially funded by EU H2020 Program and MCTI/RNP-Brazil(HPC4eProject - grant agreement number 689772), FAPERJ (MUSIC Project E36-2013) andINRIA (SciDISC 2017), INRIA international chair, U.S. National Science FoundationMCB-1158273, IOS-1139362 and MCB-1412232. This support is greatly appreciated. Bishop, C. M. (2006). Pattern recognition and machine learning. Springer, page 7. Brucato, M., Beltran, J. RF, Abouzied, A., and Meliou, A. (2016). Scalable packagequeries in relational database systems. Proc. VLDB Endow., 9(7):576—-587. 00004. Giugno, R. and Shasha, D. (2002). GraphGrep: A fast and universal method for queryinggraphs. In Proceedings - International Conference on Pattern Recognition, volume 16,pages 112-115. 2 edition. 00125. Jolion, J. (2001). Graph matching : what are we really talking about. Proceedings of the3rd IAPR Workshop on Graph-Based Representations in Pattern Recognition. Overbye, D. (2015). Astronomers observe supernova and find they’re watching reruns.New York Times, USA. R. Bank, C. D. (1993). Sparse matrix multiplication package (smmp). Advances in Computational Mathematics, 1:127—137. Samet, H. (1990). The Design and Analysis of Spatial Data Structures. Addison-Wesley. Singla, P. and Domingos, P. (2005). Object identification with attribute-mediated dependences. Proceedings of the 9th European conference on Principles and Practice ofKnowledge Discovery in Databases. U. Zwick, R. Y. (2005). Fast sparse matrix multiplication. ACM Transactions on Algorithms (TALG), 1:2-13. Zou, L., Chen, L., and Ozsu, M. T. (2009). Distance-join: Pattern Match Query in a LargeGraph Database. Proc. VLDB Endow., 2(1):886-897. Zou, L., Chen, L., Ozsu, M. T., and Zhao, D. (201 1). Answering pattern match queries inlarge graph databases via graph embedding. The VLDB Journal, 21:97-120."
}