{
    "abstract": "Database tuning usually involves indexes, materialized views, partitioning, query rewriting and other techniques. One strategy that presents goodresults for performance improvements is the use of partial indexes. However,partial indexes have not been used for database tuning in the past. This isbecause the search space for partial indexes is exponential in the number ofattributes and tuples of the table. In this paper, we address this problem byproposing an optimized strategy to select partial indexes. The optimization relies on reducing the amount of logic reads. We explain how to select the indexable attributes and their corresponding restrictions through a formal procedure.We implement our strategy to illustrate the benefits of partial indexes for tuningissues. Results are promising.",
    "1. Introduction": " Database applications have become increasingly complex and varied. These involve verylarge datasets and a high demand for good performance. The problem has always been onhow to decrease query response time while increasing the throughput (number of queriesexecuted per unit of time). In this context, tuning the physical design of database systemshas been proved to be extremely important in improving the performance of databasesystems [Shasha and Bonnet 2002]. Index tuning, as part of the physical database design, is the task of selecting, creating, deleting, and rebuilding index structures to reduce workload processing time. Amongthe activities related to database tuning, the adjustment of index structures represents oneof the most relevant. This fact stems from the great benefit that these structures bring tothe performance of database systems, since it can substantially reduce the execution timeof the queries, including updates [Shasha and Bonnet 2002]. Current index tunning approaches use regular (or complete) indexes in detrimentof partial index. A partial index [Stonebraker 1989], which is present in some of themajor Database Management Systems, indexes a subset of the tuples of a table instead ofindexing the complete set of tuples. However, the search space for defining a partial indexis exponential in the number of attributes and tuples of the table, which explains why ithas not been used by database tuning approaches up to now. In this paper, we proposean optimized strategy to select partial indexes. It is based in use cases oriented to reduce the amount of logic reads. Our strategy contemplates the use of both partial and completeindexes in automatic database tuning. It should be noted that the search for partial indexes as a tuning action includesnot only all steps followed when searching for complete indexes but also the definitionof the subset of tuples that will be accessed. Nevertheless, we propose a multi-columnpartial index approach and show that there are situations where it is worth to considerpartial indexes rather than complete indexes for performance issues. This paper is organized as follows. Section 2 defines partial indexes, while Section 3 discusses related work. In Section 4 we present a strategy to select partial indexesand combine them with complete indexes in the tuning process. Some experimental results are given in Section 5 and Section 6 concludes, listing our main contributions.",
    "2. Preliminaries": " Stonebraker defines partial indexes as constrained indexes with a WHERE clause, whichdefines a subset of tuples to be indexed on a table [Stonebraker 1989]. For example, wecould define a partial index PJ for table T’ with two columns A and B, as follows. In thiscase, only tuples from T that have attribute B valued “X’ or ‘W’ would be indexed. CREATE INDEX PI ON T (A, B) WHERE B = ’X’ or B= ‘W’; A partial index P can be used in the execution of a query Q if and only if thepredicate of Q logically implies the conditional expressions of the partial index P. Forinstance, consider query © below that is run over table 7’: It is easy to note that the partial index PJ above contains enough information tofind the tuples of T' satisfying query Q, since the selection predicate of Q logically impliesthe selection predicate of PI. We denote this set of tuples T(Q). Partial indexes are beneficial because they can avoid indexing frequent values.When a query retrieves a set of values of more than a small percentage of all table rows,the DBMS does not use the index. Then there is no point in keeping those tuples in theindex. This strategy reduces the size of the index, which speeds up the index creation timeand reduces space requirements. It also speeds up many table update operations becausethe index does not need to be updated in all cases [PostgreSQLv9 2018]. Partial indexes may favor better performance than complete indexes because of thesmaller size of their access structures. For example, consider a complete index C’ and apartial index PJ, both using a B+-tree on attributes A and B as the physical data structure,where the partial index has a set of restrictions R. If we have a query Q for which bothC' and PI are useful, it might be possible that the number of scanned blocks using PJ toanswer ( will be smaller than the number of scanned blocks using C’. Figure | illustratesthis case for query Q = A > Oand A < 10 and B =\" X\". Both indexes (complete andpartial) were built with a B+-tree, and the leaf nodes represent data entries that point tophysical data. In this case, the number of scanned entries using the partial index can besmaller than the number of entries scanned with the complete index. For this particularexample, it is in fact — while the complete index scans 21 data entries, the partial indexscans only 10 data entries to answer the query Q. B+-Tree of B+-Tree ofComplete Index Partial Indexa1;1/1/)2/3/3/4/4/4|4]/5/5/6/6 7|8|8 9/9 1/3|4/4|5/6 8 9XI/YIZIY|X|Z], XYZ Y X| Y Z|X|Y X|Y X| X| X X X X Figure 1. Representation of scanned data entries in Partial and Complete indexesfor Query Q: A >0 and A<10 and B = ’X’. Values for attribute A are representedin the first row of leaf nodes, while values for attribute B are in the second row. Finding complete indexes that may benefit a workload can be a difficult task. Besides choosing a set of attributes suitable to index creation, we also need to choose theorder in which they will be indexed. There is a large number of combinations to check.The case of partial indexes is even more complex since it requires the same phases thatcomplete indexes need and also an extra step to determine a subset of tuples which willbe indexed by the partial index (the restricting selection clause).",
    "3. Related Work": " The index selection problem has been studied for many years by the database researchcommunity [Lightstone 2009]. There are two families of research in this area, whichfocus on development of algorithms and data structures that optimize the maintenancecost of indexes and other access structures [Labio et al. 1997], or that develop algorithmsto optimize query response time [Gupta et al. 1997, Agrawal et al. 2001]. Studies aboutoptimization of query response time may be categorized depending on how the set ofcandidate indexes is selected. In this work we are interest in the second family of research Some related work about index performance focus in partial indexes as an alternative data structure. In fact, there are some cases where partial indexes are particularlyuseful. We discuss three situations here: (1) focus on low maintenance of the indexes; (11)focus on saving space; and (111) focus on reducing logical reads. Partial indexes are useful when we have sets of tuples with a high percentage of requests and an update rate smaller than the average of updates in the table[Stonebraker 1989]. In this first situation, approaches in literature use partial indexesas a way to obtain access structures with a low maintenance cost and high perforWe may cite research work that fit to this criteria distributed in two maingroups of adaptive indexing: database cracking and adaptive merging. Database cracking [Graefe and Kuno 2010a, Graefe and Kuno 2010b] combines features of automaticindex and partial indexes selection by indexing results of each query. Each partitioning step creates two new sub-partitions using a logic similar to partitioning in quicksort [Idreos et al. 2011]. While database cracking functions as an incremental quicksort, with each query resulting in at most one or two partitioning steps, adaptivemerging [Idreos et al. 2007a, Idreos et al. 2007b, Idreos et al. 2009, Voigt et al. 2012,Graefe et al. 2014] functions as an incremental merge-sort, with one merge step applied to all key ranges in a query result. Under adaptive merging, the first query to use a givencolumn in a predicate produces sorted runs. Each subsequent query on that same columnapplies to at most one additional merge step, that only affects those key ranges that arerelevant to actual queries, leaving records in all other key ranges in their initial places[Idreos et al. 2011]. The second situation covers those cases where complete indexes are very expensive due to space constraints [Seshadri and Swami 1995]. Research work that fit in thissituation [Chen et al. 2011, Wu et al. 2008] exclude from the index those sets of tupleswith high selectivity, or low probability to be queried. There are tuples that do not takeadvantage of indexes benefits and lack of interest in the current workload. Last but not least, the third situation is the one we explore in this paper. Weclaim that the use of multi-column partial indexes is a good alternative to improve queryperformance. We remove the space constrains of the second alternative and introduce anew view of partial indexes to reduce the number of logical reads in a workload.",
    "4. Tuning with partial indexes": " We advocate that the tuning process must take into consideration solutions containingboth partial and complete indexes. The selection process of partial indexes can be dividedinto the following phases: (1) selection of indexable attributes (i1) definition of restrictionsfor partial indexes and (i11) final index configuration. These steps should ensure that anypartial index chosen to be part of the final access structure configuration of a databasesystem has a high probability of being used. Moreover, it should bring actual benefitsduring the workload execution. Each of these phases is discussed next.",
    "4.1. Step 1: Selection of indexable attributes": " An index is a copy of values from selected columns of a table that can be searched veryefficiently. It includes a low-level disk block address or a direct link to the complete rowof data it was copied from. The order in which the index definition specifies the columnsis important. It is possible to retrieve a set of row identifiers using only the first indexedcolumn. However, it is not possible or efficient (on most databases) to retrieve the set ofrow identifiers using only the second or greater indexed column(s). We call indexable attributes of a query the sets of attributes belonging to the sametable operated by the AND operator for which it makes sense to create an index. Forexample, in the following query, the set of possible sets of indexable attributes is A; ={{A}.{B }. {A.B } } In order to obtain the sets of indexable attributes in a workload, we perform an automatic analysis of the predicate at the WHERE clause of each query. The analysis derivesnew clauses expressed as a disjunction of conjunctions, that is equivalent to the originalclause. The procedure consists in modeling the operations in the WHERE clause in a treerepresenting the priority of operations and rotating the tree according to the equivalenceof operations until no node representing an OR logic operation has an AND node as itsparent. Figure 2(a) represents a clause (A OR B) AND C, where internal nodes are logicoperations and leaf nodes are restrictions (predicates). Figure 2(b) represents a rotation Figure 2. (a) Tree of operations of a given query; (b) Rotation of the tree in (a) sothat no OR operation has an AND operation as its parent of Figure 2(a) once a node OR with a parent AND is found. We use this modified tree toobtain the indexable attributes, which in this case are {{A}, {B},{C}, {A, B}$,{B,C}}. Since indexes are defined over attributes of the same table, the second step residesin separating attributes that belong to the same table. The sets of indexable attributesare obtained by looking for sets of restrictions (predicates) with attributes in the sametable belonging to the same subtree with AND root node type. Once the sets of indexableattributes for each query are obtained, we may find some sets of indexable attributesrepeated multiple times. These sets are those that appear more frequently in the queriesof the workload, therefore, they are candidates for the creation of partial indexes. We use a method based on conceptual lattices [Gouda and Zaki 2001] (hierarchical structure under the subset operation representing a partial order) to obtain frequent setsof indexable attributes. The data structure used for the representation of the conceptuallattices in this work is a Trie [Fredkin 1960], that counts the number of times that eachset of attributes appear in the workload. Figure 3 shows a Trie representing the sets of indexable attributes A; = {{A,C}, {B,C}, {C, D}, {D}}. In this example, if a set havingthree or more occurrences is considered frequent, then the attribute C’ must be marked asfrequent and a terminal node is associated. A set of indexable attributes is considered frequent if the proportion between theset of indexable attributes and the total number of extracted sets of indexable attributes is above a given threshold t, assuming an uniform distribution. This gives us an estimate ofthe number of times a given index would be useful in a query workload. The threshold tis calculated as 1/|A;|, where |A,| is the cardinality of the set of indexable attributes. Once the sets of indexable attributes of each table are determined, we need a strat egy to assess the impact of the candidate indexes in the workload performance. In other words, we need to identify the indexes that could be defined over the sets of indexableattributes. Hence, we adopt an heuristics of benefits to evaluate candidate indexes oversets of indexable attributes. This heuristics consists of finding, for each query of the workload, a set of candidate indexes with the higher benefit to the query according to a costmodel. To do so, we obtain an aggregation of gains by estimating, for each query, the costof running that query without the index minus the cost of executing the query with theindex. Then, we obtain the benefit of that particular index by calculating the aggregatedgain of the index minus its maintenance cost.",
    "4.2. Step 2: Selection of restrictions": " Let Tab be a table having a set of attributes A and a set of tuples 7’, where the roundnumber of tuples fitting into a block is d. Let CT be a complete index defined over aset of indexable attributes A; and PJ a partial index defined over the same set of indexable attributes A, having the set of restrictions RS. Each element R € RS represents a set of restrictions (predicates) relative to a subset of indexable attributes of A;.For example, consider the definition of the partial index PJ below. We can representthis partial index by a set of indexable attributes A, = {A,B} and the set of predicatesRS ={{B='X {B= W'S}. Moreover, let @ be a query represented by a set of indexable attributes A, ={ a1, A2,...,@,} and a set of predicates Q, = {pi,p2,...,Pn}, where each predicate p;restricts a subset of attributes of A,. For example, considering a table Tab with the attributes {A, B,C} the query defined below can be represented by the sets A, = {A, B}and@, = {{A>2,B=' X’}}. To calculate the profit (gain) G of a partial index, we find the difference betweenthe number of blocks scanned using the complete index C’J and the number of blocksscanned using the partial index PJ. Equation | shows a formula for estimating G bycalculating the proportion of non scanned tuples to answer query Q and multiplying it bythe total number of blocks in the table. In the formula, 7(C’) denotes the number of tuplessatisfying C’. C'can be either a query or the restrictions on an index. 7’ is the total numberof tuples in the table. For each a; € A,, we define CQ; = T(X) and CQ; = T(Y), suchthat X and Y are the set of predicates (restrictions) p; (X C p;, Y C p; and X # Y)associated to the set of indexable attributes of the set A; M a; and a; \\ A; respectively. We then define the amount of scanned blocks B for executing the query Q (Equation 2). The notation S.B(CQ;, CQ) represents the amount of blocks scanned in the tablewhen using an index. We assume in Equation | that the non-scanned tuples have a uniform distributionover the key A; of the index. Moreover, the term SB(CQ;, CQ‘) can be calculated usingthe results in [Mackert and Lohman 1989], that estimate the number of disk page fetcheswhen randomly accessing /& records out of n given records stored on p disk pages. When we divide Equation | by Equation 2, the result quantifies how good is thebenefit of using the partial index compared to the execution of Q using the complete index.Equation 3 assumes we are only interested in partial indexes having a benefit greater thana threshold w. The partial index would be used only if the cost is less than a full scan. LetTB be the number of blocks occupied by the tuples of table J’ab, assuming an uniform Each restriction belonging to PJ must comply to Equation 4 ensuring the partialindex does reduce the number of logical reads. However, we also need to ensure thattuples in a partial index will have a high probability of being accessed. We define a similarity function s(p;, p2) between predicates p, and p and a ranking function rank(p, Q,)for predicate p regarding the set of predicates (),, as: Then, it is possible define the restrictions of a partial index PJ defined in a set ofattributes A; using the set of restrictions RS belonging to any set of indexable attributes A in the queries of a workload, just by solving the following integer programming problem.In this program, variable a; must have an integer value in the set {0 , 1}. This valuedenotes if the restriction 7; can be part of the restrictions of PT.",
    "4.3. Step 3: Final configuration": " We have so far presented a methodology that finds indexable attribute sets for a givenworkload. These sets are candidates for the creation of either partial or complete indexes.Furthermore, let C’ be an indexable attribute set, w a workload and RS a set of conjunctions belonging to queries in w involving constraints on attributes in C’. We present amethod that may obtain a set P of conjunctions that together with those constraints in C’represent a partial index noted by (C’, P). The corresponding complete index (C’, U) takesinto account the universal set of all possible conjunctions. However, the whole process may generate multiple partial and complete candidateindexes, as we do not consider the relationship of these indexes with the workload. Wemay cite as an example a table 7’ containing attributes A, B, C and D, and query Q, inSQL in workload w: Now, consider six possible indexable attribute sets that are frequent in wi:{{A}, {B}, {C}, {D}, {A, B}, {C, D}}. These sets imply complete candidate indexesthat could be used by query @, separately. Thus, some of them would become redundantfor this query. To avoid such a situation, we consider an algorithm that outputs all possibledistinct candidate indexes that may be obtained from all candidate indexes generated in Let C;; be a set of indexable attributes that are frequent in a workload w and P; aset of constraints. Function fo computes the execution cost considering w and candidatestructures in O as input. Note that the i“” candidate structure would be a complete index Therefore, it is possible to run an algorithm that starts with an empty candidatestructures set O and at each step, adds candidate structure C’ in O, that together withthose structures already in O can minimize the execution cost for w concerning fo. Thatis, at each step we determine C' in O, that minimizes fo({< Ci, P; >}UO). Onceavailable, C’ will be added to O whenever it increases the minimum value for fo in the",
    "5. Experiments": " Our work intends to show that, in some cases, partial indexes may be used to improveperformance rather than complete indexes. This happens because multicolumn partialindexes, with any non-categorical column in the left-most column and restrictions in anyof the right-most column, can reduce the amount of logic reads in queries using the partialindex when compared to the corresponding complete index. In order to show that partial indexes may reduce the amount of logical reads, weimplemented a prototype of the proposed solution in the DBX [BiobdPUC-Rio 2018]framework, whose architecture enables incorporating several database tuning solutions.Our prototype is used to generate configurations consisting of both partial and completeindexes, and also configurations consisting of only complete indexes as a result of the Methodology. All our experiments were run on PostgreSQL v9 DBMS, on a 64 bitcomputer with a 1.6GHz Quad-Core processor, 16GB of RAM and ITB hard disk drive.We have used a database obtained from the TPC-H benchmark, configured to a scale of100 GB. Just to mention a few examples, in this case the largest table (LineItem) has over600 million tuples and 90MB. The supplier table has a smaller number of tuples (30,000)but uses more than 1 70MB, almost twice as much as Lineltem. We instantiated 8 queries out of 22 generic queries in the TPC-H benchmark.These involve simple queries in the sense that no nested queries are taken into account. Wehave generated 100 queries using these TPC-H queries by randomly choosing a genericquery at each time. The execution of the experiment was developed in two phases. Thefirst phase consisted of the execution of the workload using DBX to generate configurations of complete indexes only. In the second phase, DBX was tailored to generateconfigurations of both partial and complete indexes. This way, it was possible to determine how good partial indexes might be when compared to complete indexes. We havechosen to compare the behavior of the query execution times and also the number of logical reads for each query. It is worth noting that the time spent in query execution wasmeasured by executing each query 10 times, discarding the first measure and computingthe average of the remaining executions. Results and discussion. The first thing we could find out about partial indexes in ourresearch is that for single column indexes, there is no difference in the performance ofquery execution between partial indexes and complete indexes. This is reflected in theEquation 3 where the number of non scanned tuples for the partial index is 0. Using the configurations suggested by the prototype implemented in DBX, wehave compared the configurations of partial indexes and complete indexes, with the corresponding configuration of only complete indexes, by measuring the amount of logicreads and the execution times. Figure 4 shows the number of logic reads. The differenceof logic reads in the generic queries (4, Q6 and Q8 is due to the existing partial indexes.We get a reduction of logical reads of approximately 8%, 47%, and 64%, which showsthat our strategy to select partial indexes have achieved good results. Note that Q4, Q6and (8 are the only queries in the workload for which partial indexes were created. Thisis way the amount of logic reads for the other queries are the same. When we analyze the query execution plan for @8, we note that the complete",
    "1.200.000. 000, 00": "",
    "1.000.000. 000, 00": " avg, | SOANGT96 [7 | P7802 | T0371 | 2.595.876 | 13.625 | 0.0001 |os | | 896.590 | —SSS~« 2S | 1.172.261 | 9.578 | 0.0001 index is not used. This happens because the partial index reduces the number of blocks tobe read when compared to the complete index. A reduction in the amount of logic readsimplies a reduction in the query execution time. Indeed, Figure 5 shows that the executiontime for queries (4, Q6 and @8 do decrease. The next step of our evaluation comprises checking whether the reduction onquery processing time when using partial indexes for queries @4, Q6 and Q8 are statistically significant. To show this, we have considered the hypothesis test of mean (oraverage) difference. This test is based on an attempt to reject the null hypothesis thattwo variables are equal. Specifically, we intend to reject the hypothesis that the executiontime for queries @4, Q6 and Q8 is the same for the configuration with both completeand partial indexes and the configuration with only complete indexes. Table | shows theresults of our hypothesis test. In this table, #/nstances refers to the number of instancesof the generic query we used (please note that each instance was executed 10 times, asmentioned before). AVG is the mean of query execution time, and a is the standard deviation. For those three queries, the difference in the mean execution time is statisticallysignificant (p-value < 0.05).",
    "6. Conclusions": " This work shows that partial indexes are useful data access structures capable of improving query execution time. Particularly, we show that multi-column partial indexes can be used to improve performance since it can reduce the amount of logical reads needed toprocess a query. We have identified at least two situations where multi-column partialindexes are effective: (i) for sets of tuples frequently queried and (11) when there are veryselective attributes. These are very common situations in practice. Therefore, it is worthcounting on partial index as an additional way of obtaining efficient database systems. Our contribution resides in an approach for database tuning that is capable ofgenerating configurations for both partial and complete indexes. The proposed strategyis based on use cases identified for partial indexes. We have implemented and testedour proposal considering a standard OLTP benchmark (TPC-H). The obtained results arepromising and show situations where partial indexes are used by the query optimizer evenwhen the corresponding complete indexes are present. We invite the reader to check otherresults at [Fuentes 2016]. We intend to continue this research work by further studying the influence of theorder of attributes in partial indexes. In addition, our approach could also be considered Agrawal, S., Chaudhuri, S., and Narasayya, V. R. (2001). Materialized view and indexselection tool for microsoft SQL server 2000. In SIGMOD Conf., page 608. ACM. Aouiche, K. and Darmont, J. (2009). Data mining-based materialized view and indexselection in data warehouses. J. Intell. Inf. Syst., 33(1):65-93. BiobdPUC-Rio (2018). Dbx. https: //github.com/BioBD/dbx. [April-03-18]. Chen, C., Li, F, Ooi, B. C., and Wu, S. (2011). TI: an efficient indexing mechanism forreal-time search on tweets. In SIGMOD Conference, pages 649-660. ACM. Fuentes, A. D. (2016). Automatic fine tuning with partial indexes (in portuguese). Master’s thesis, PUC-Rio Informatica, Rio de Janeiro, Brasil. Gouda, K. and Zaki, M. J. (2001). Efficiently mining maximal frequent itemsets. InICDM, pages 163-170. IEEE Computer Society. Graefe, G., Halim, F., Idreos, S., Kuno, H. A., Manegold, S., and Seeger, B. (2014).Transactional support for adaptive indexing. VLDB J., 23(2):303-328. Graefe, G. and Kuno, H. A. (2010a). Adaptive indexing for relational keys. In ICDEWorkshops, pages 69-74. IEEE Computer Society. Graefe, G. and Kuno, H. A. (2010b). Self-selecting, self-tuning, incrementally optimizedindexes. In EDBT, Intl Conf, pages 371-381. ACM. Gupta, H., Harinarayan, V., Rajaraman, A., and Ullman, J. D. (1997). Index selection forOLAP. In JCDE, pages 208-219. IEEE Computer Society. Idreos, S., Kersten, M. L., and Manegold, S. (2007a). Database cracking. In CIDR, pages Idreos, S., Kersten, M. L., and Manegold, S. (2007b). Updating a cracked database. InSIGMOD Conference, pages 413-424. ACM. Idreos, S., Kersten, M. L., and Manegold, S. (2009). Self-organizing tuple reconstructionin column-stores. In SIGMOD Conference, pages 297-308. ACM. Idreos, S., Manegold, S., Kuno, H. A., and Graefe, G. (2011). Merging what’s cracked,cracking what’s merged: Adaptive indexing in main-memory column-stores. PVLDB,4(9):585—597. Labio, W., Quass, D., and Adelberg, B. (1997). Physical database design for data warehouses. In ICDE, pages 277-288. IEEE Computer Society. Lightstone, S. (2009). Physical database design for relational databases. In Encyclopediaof Database Systems, pages 2108-2114. Springer US. Mackert, L. F. and Lohman, G. M. (1989). Index scans using a finite LRU buffer: Avalidated I/O model. ACM Trans. Database Syst., 14(3):401-424. PostgreSQLv9 (2018). Partial indexes documentation. http://www.postgresql.org/docs/9.4/static/indexes-partial.html. [April-03-18]. Seshadri, P. and Swami, A. N. (1995). Generalized partial indexes. In ICDE, pages420-427. IEEE Computer Society. Shasha, D. E. and Bonnet, P. (2002). Database Tuning - Principles, Experiments, andTroubleshooting Techniques. Elsevier. Stonebraker, M. (1989). The case for partial indexes. SIGMOD Record, 18(4):4-11. Voigt, H., Jakel, T., Kissinger, T., and Lehner, W. (2012). Adaptive index buffer. In JCDEWorkshops, pages 308-314. IEEE Computer Society. Wu, S., Li, J., Ooi, B. C., and Tan, K. (2008). Just-in-time query retrieval over partiallyindexed data on structured P2P overlays. In SIGMOD Conf., pages 279-290. ACM."
}